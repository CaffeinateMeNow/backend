---

- name: Send notification about started deployment on Slack
  slack:
    token: "{{ slack_webhook_token }}"
    msg: "Started deploying to {{ ansible_host }}"
  when: slack_webhook_token is defined and slack_webhook_token
  tags:
    - deploy

- name: Stop Apache
  when: "'core_services' in group_names"  # only for hosts in 'core_services' group
  tags:
    - deploy
  block:

    - name: "Stop Apache service"
      service:
        name: apache2
        state: stopped
      become: "{{ ansible_distribution == 'Ubuntu' }}"
      become_user: root
      tags:
        - deploy

    - name: "Wait for Apache to stop"
      pause:
        seconds: 5
      tags:
        - deploy

    - name: "Test if Apache service is stopped"
      command: "pgrep {% if ansible_distribution == 'Ubuntu' %}apache2{% else %}httpd{% endif %}"
      register: apache_status
      failed_when: apache_status.stdout_lines | count > 0
      changed_when: false
      tags:
        - deploy

    # Sometimes Apache doesn't manage to kill all Perl FCGI handlers
    - name: "Test if any Perl FCGI handlers are still up"
      command: "pgrep perl-fcgi"
      register: perl_fcgi_status
      failed_when: perl_fcgi_status.stdout_lines | count > 0
      changed_when: false
      tags:
        - deploy

- name: Stop Supervisor
  tags:
    - deploy
  block:

    - name: "Stop all Supervisor services"
      command: "{{ mediacloud_root }}/supervisor/supervisorctl.sh stop all"
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Stop Supervisord"
      command: "{{ mediacloud_root }}/supervisor/supervisorctl.sh shutdown"
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Wait for Supervisor to stop"
      pause:
        seconds: 5
      tags:
        - deploy

    - name: "Test if Supervisord is stopped"
      command: "pgrep supervisord"
      register: supervisor_status
      failed_when: supervisor_status.stdout_lines | count > 0
      changed_when: false
      tags:
        - deploy

    # Supervisor doesn't always kill all crawler processes
    - name: "Test if crawler is stopped"
      shell: "ps -ax | grep -s perl | grep -s crawl.pl | grep -sv grep | awk '{ print $1 }'"
      register: crawler_pids
      changed_when: false
      when: "'core_services' in group_names"  # only for hosts in 'core_services' group
      tags:
        - deploy

    - name: "Kill leftover crawler processes"
      command: "kill {{ item }}"
      with_items: "{{ crawler_pids.stdout_lines }}"
      when: "'core_services' in group_names and crawler_pids.stdout_lines | count > 0"
      failed_when: false
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Test if crawler is stopped after killing leftover crawler processes"
      shell: "ps -ax | grep -s perl | grep -s crawl.pl | grep -sv grep | awk '{ print $1 }'"
      register: crawler_pids
      failed_when: >
        crawler_pids is failed or
        crawler_pids.stdout_lines | count > 0
      changed_when: false
      when: "'core_services' in group_names"  # only for hosts in 'core_services' group
      tags:
        - deploy

- name: Check out Media Cloud Git repository
  git:
    repo: "{{ git_repo_url }}"
    dest: "{{ mediacloud_root }}"
    version: "{{ git_clone_branch }}"
    clone: false
  become: true
  become_user: "{{ mediacloud_user }}"
  tags:
    - deploy

- name: Upgrade database schema
  when: "'core_services' in group_names"  # only for hosts in 'core_services' group
  tags:
    - deploy
  block:

    - name: "Run database schema upgrade script"
      command: "./script/run_in_env.sh ./script/upgrade_db.pl --import"
      register: upgrade_db_status
      args:
        chdir: "{{ mediacloud_root }}"
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Print database schema upgrade script output"
      debug:
        var: upgrade_db_status.stderr_lines
      tags:
        - deploy

# 1. When deploying, we usually stop Supervisor and all of its managed services
#    and restart them afterwards
# 2. copy_nonpartitioned_sentences_to_partitions - the sentence chunk copier
#    script - is one of the Supervisor services
# 3. The script uses run_alone() because we want to run only a single instance
#    of this script at any time
# 4. run_alone() works by creating a lock file and subscribing to
#    SIGINT / SIGTERM to clean up the lock file before exiting.
# 5. Supervisor tries to stop the chunk copier script with SIGINT first before
#    resorting to SIGKILL. The problem is, due to this bug (I think), if the
#    script is waiting for a response from a SQL query made via psycopg2,
#    run_alone()'s signal handlers don't get called.
# 6. So, Supervisor kills the script with SIGKILL (i.e. no lock file cleanup
#    gets done), and restarting the script fails because run_alone()'s lock
#    file already exists.
- name: Remove copy_nonpartitioned_sentences_to_partitions lock file
  file:
    path: "/var/run/lock/d49860781c55a8eb64bfeee811e126261ec8a60fe93794b5cfbfbfac68d0f9ca"
    state: absent
  become: true
  become_user: "{{ mediacloud_user }}"
  tags:
    - deploy    

- name: Start Supervisor
  tags:
    - deploy
  block:

    - name: "Start Supervisord"
      command: "{{ mediacloud_root }}/supervisor/supervisord.sh"
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Wait for Supervisor to start"
      pause:
        seconds: 5
      tags:
        - deploy

    - name: "Test if Supervisord is started"
      command: "pgrep supervisord"
      register: supervisor_status
      failed_when: supervisor_status.stdout_lines | count == 0
      changed_when: false
      tags:
        - deploy

    # In case "start_no_supervisor_programs" is set
    - name: "Start RabbitMQ manually"
      command: "{{ mediacloud_root }}/supervisor/supervisorctl.sh start job_broker:rabbitmq"
      changed_when: false
      become: true
      become_user: "{{ mediacloud_user }}"
      when: "'core_services' in group_names"  # only for hosts in 'core_services' group
      tags:
        - deploy

    - name: "Wait for RabbitMQ to start up"
      wait_for:
        port: 15673
        delay: 2
        timeout: 60
      when: "'core_services' in group_names"  # only for hosts in 'core_services' group
      tags:
        - deploy

    - name: "Wait for all Supervisor services to start"
      command: "{{ mediacloud_root }}/supervisor/supervisorctl.sh status"
      retries: 10
      delay: 3
      register: supervisorctl_status
      until: >
        supervisorctl_status.rc == 0 and
        'STARTING' not in supervisorctl_status.stdout
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

    - name: "Check if any of the Supervisor services have failed to start"
      command: "{{ mediacloud_root }}/supervisor/supervisorctl.sh status"
      register: supervisorctl_status
      failed_when: >
        supervisorctl_status is failed or
        'BACKOFF' in supervisorctl_status.stdout or
        'EXITED' in supervisorctl_status.stdout or
        'FATAL' in supervisorctl_status.stdout or
        'UNKNOWN' in supervisorctl_status.stdout
      changed_when: false
      become: true
      become_user: "{{ mediacloud_user }}"
      tags:
        - deploy

- name: Start Apache
  when: "'core_services' in group_names"  # only for hosts in 'core_services' group
  tags:
    - deploy
  block:

    - name: "Start Apache service"
      service:
        name: apache2
        state: started
      become: "{{ ansible_distribution == 'Ubuntu' }}"
      become_user: root
      tags:
        - deploy

    - name: "Wait for Apache to start"
      pause:
        seconds: 5
      tags:
        - deploy

    - name: "Test if Apache service is started"
      command: "pgrep {% if ansible_distribution == 'Ubuntu' %}apache2{% else %}httpd{% endif %}"
      register: apache_status
      failed_when: "apache_status.stdout_lines | count == 0"
      changed_when: false
      tags:
        - deploy

    - name: "Test if status page works"
      uri:
        url: "{% if apache2_ssl_enabled %}https{% else %}http{% endif %}://{{ apache2_server_name }}/status"
        return_content: yes
      register: status_page
      tags:
        - deploy

    - name: "Ensure that status page works"
      assert:
        that:
          - "'Works!' in status_page.content"
      tags:
        - deploy

- name: Send notification about finished deployment on Slack
  slack:
    token: "{{ slack_webhook_token }}"
    msg: "Finished deploying to {{ ansible_host }}"
  when: slack_webhook_token is defined and slack_webhook_token
  tags:
    - deploy
